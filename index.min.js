"use strict";

function error(err) {
    err && logger(err.message);
}

function jsonParser() {
    return {
        parse: JSON.parse
    };
}

function bsonParser() {
    var BSON = require("bson");
    return BSON = new BSON(), {
        parse: BSON.deserialize
    };
}

function someCollections(db, collections, next) {
    var last = ~~collections.length, counter = 0;
    if (0 === last) return next(null);
    collections.forEach(function(collection) {
        db.collection(collection, function(err, collection) {
            if (logger("select collection " + collection.collectionName), err) return last === ++counter ? next(err) : error(err);
            collection.drop(function(err) {
                return err && error(err), last === ++counter ? next(null) : null;
            });
        });
    });
}

function wrapper(my) {
    function callback(err) {
        logger("restore stop"), null !== my.callback ? (logger("callback run"), my.callback(err)) : err && logger(err);
    }
    function streamingTarDataSource(tarStream) {
        return {
            begin: function(streamListener, callback) {
                var extract = require("tar-stream").extract();
                extract.on("entry", function(header, stream, next) {
                    "directory" === header.type ? streamListener.onDirectory(header.name, next) : "file" === header.type ? streamListener.onFile(header.name, stream, next) : next(), 
                    stream.resume();
                }), extract.on("finish", function() {
                    streamListener.finish(callback);
                }), tarStream.pipe(extract);
            }
        };
    }
    function go(datasource) {
        require("mongodb").MongoClient.connect(my.uri, my.options, function(err, db) {
            function importDataToDb(err) {
                if (err) return logger("db close"), db.close(), callback(err);
                datasource.begin(streamListener(parser, writer(db), my.metadata), function(err) {
                    logger("db close"), db.close(), callback(err);
                });
            }
            return logger("db open"), err ? callback(err) : !0 === my.drop ? (logger("drop database"), 
            db.dropDatabase(importDataToDb)) : my.dropCollections ? (logger("drop collections"), 
            !0 === Array.isArray(my.dropCollections) ? someCollections(db, my.dropCollections, importDataToDb) : db.collections(function(err, collections) {
                err && error(err), my.dropCollections = [];
                for (var i = 0, ii = collections.length; i < ii; ++i) {
                    var collectionName = collections[i].collectionName;
                    !1 === systemRegex.test(collectionName) && my.dropCollections.push(collectionName);
                }
                someCollections(db, my.dropCollections, importDataToDb);
            })) : void importDataToDb(null);
        });
    }
    var parser;
    if ("function" == typeof my.parser) parser = my.parser; else switch (my.parser.toLowerCase()) {
      case "bson":
        parser = bsonParser();
        break;

      case "json":
        parser = jsonParser();
        break;

      default:
        throw new Error("missing parser option");
    }
    if (null === my.logger) logger = function() {}; else {
        (logger = require("logger-request")({
            filename: my.logger,
            standalone: !0,
            daily: !0,
            winston: {
                logger: "_mongo_r" + my.logger,
                level: "info",
                json: !1
            }
        }))("restore start");
        var log = require("mongodb").Logger;
        log.setLevel("info"), log.setCurrentLogger(function(msg) {
            logger(msg);
        });
    }
    if (!my.tar) return go(function(rootDir) {
        var addCollections = function(streamListener, collections, callback) {
            if (0 !== collections.length) {
                var collectionName = collections.pop();
                streamListener.onDirectory(collectionName, function(err) {
                    error(err), addCollections(streamListener, collections, callback);
                });
            } else callback(null);
        }, addFiles = function(streamListener, files, callback) {
            if (0 !== files.length) {
                var filename = files.pop();
                streamListener.onFile(filename, fs.createReadStream(filename), function(err) {
                    error(err), addFiles(streamListener, files, callback);
                });
            } else callback(null);
        };
        return {
            begin: function(streamListener, callback) {
                var dirs = fs.readdirSync(rootDir);
                if (1 === dirs.length) {
                    var dbRootDir = path.join(rootDir, dirs[0]), collections = fs.readdirSync(dbRootDir).map(function(dir) {
                        return path.join(dbRootDir, dir);
                    });
                    addCollections(streamListener, collections, function(err) {
                        error(err);
                        var directoryArrays = fs.readdirSync(dbRootDir).map(function(dirname) {
                            return fs.readdirSync(path.join(dbRootDir, dirname)).map(function(filename) {
                                return path.join(dbRootDir, dirname, filename);
                            });
                        }), allFiles = [].concat.apply([], directoryArrays);
                        addFiles(streamListener, allFiles, function(err) {
                            error(err), streamListener.finish(callback);
                        });
                    });
                } else callback("Found multiple directories and only support one: " + JSON.toString(dirs));
            }
        };
    }(my.root));
    go(null !== my.stream ? streamingTarDataSource(my.stream) : function(tarFile) {
        return streamingTarDataSource(fs.createReadStream(tarFile));
    }(my.root + my.tar));
}

function restore(options) {
    var opt = options || Object.create(null);
    if (!opt.uri) throw new Error("missing uri option");
    if (!opt.stream) {
        if (!opt.root) throw new Error("missing root option");
        if (!fs.existsSync(opt.root) || !fs.statSync(opt.root).isDirectory()) throw new Error("root option is not a directory");
    }
    var my = {
        dir: path.join(__dirname, "dump", path.sep),
        uri: String(opt.uri),
        root: path.resolve(String(opt.root)) + path.sep,
        stream: opt.stream || null,
        parser: opt.parser || "bson",
        callback: "function" == typeof opt.callback ? opt.callback : null,
        tar: "string" == typeof opt.tar ? opt.tar : null,
        logger: "string" == typeof opt.logger ? path.resolve(opt.logger) : null,
        metadata: Boolean(opt.metadata),
        drop: Boolean(opt.drop),
        dropCollections: Boolean(opt.dropCollections) ? opt.dropCollections : null,
        options: "object" == typeof opt.options ? opt.options : {}
    };
    my.stream && (my.tar = !0), wrapper(my);
}

var systemRegex = /^system\./, fs = require("graceful-fs"), path = require("path"), logger, streamListener = function(parser, writer, supportMetadata) {
    var collectionNameForDirectory = new RegExp(".*/([^/]+)/?$"), collectionNameForFiles = new RegExp(".*/([^/]+)/[^/]+$"), metadataFilenameRegexp = new RegExp(".*/[^/]+/([^/]+)$"), metadata = [];
    return {
        onDirectory: function(directoryName, callback) {
            var collectionName = collectionNameForDirectory.exec(directoryName.replace(/\\/g, "/"))[1];
            ".metadata" !== collectionName ? writer.createCollection(collectionName, callback) : callback(null);
        },
        onFile: function(name, stream, callback) {
            var collectionName = collectionNameForFiles.exec(name.replace(/\\/g, "/"))[1];
            if (".metadata" === collectionName) {
                var metadataName = metadataFilenameRegexp.exec(name.replace(/\\/g, "/"))[1];
                if (!supportMetadata) return void callback(null);
            }
            var buffers = [];
            stream.on("data", function(buffer) {
                buffers.push(buffer);
            }), stream.on("end", function() {
                if (".metadata" === collectionName) return metadata.push({
                    collectionName: metadataName,
                    document: jsonParser().parse(Buffer.concat(buffers))
                }), void callback(null);
                writer.addDocument(collectionName, parser.parse(Buffer.concat(buffers)), callback);
            });
        },
        finish: function(callback) {
            writer.drain(function(err) {
                error(err), supportMetadata ? writer.addIndices(metadata, function(err) {
                    error(err), callback();
                }) : callback();
            });
        }
    };
}, writer = function(db) {
    var dataToWrite = {}, writeAllInCollection = function(collectionName, callback) {
        var operations = dataToWrite[collectionName].map(function(document) {
            return {
                insertOne: {
                    document: document
                }
            };
        });
        0 !== operations.length ? db.collection(collectionName, function(err, collection) {
            error(err), collection.bulkWrite(operations, function(err) {
                delete dataToWrite[collectionName], callback(err);
            });
        }) : callback(null);
    }, writer = {
        createCollection: function(collectionName, next) {
            db.createCollection(collectionName, next);
        },
        addDocument: function(collectionName, document, next) {
            Array.isArray(dataToWrite[collectionName]) ? dataToWrite[collectionName].push(document) : dataToWrite[collectionName] = [ document ], 
            dataToWrite[collectionName].length > 50 ? writeAllInCollection(collectionName, function(err) {
                next(err);
            }) : next(null);
        },
        drain: function(callback) {
            if (0 !== Object.keys(dataToWrite).length) {
                var collectionName = Object.keys(dataToWrite)[0];
                writeAllInCollection(collectionName, function(callback, err) {
                    error(err), writer.drain(callback);
                }.bind(this, callback));
            } else callback(null);
        },
        addIndices: function(indices, callback) {
            if (0 !== indices.length) {
                var collectionAndIndexes = indices.pop();
                db.command({
                    createIndexes: collectionAndIndexes.collectionName,
                    indexes: collectionAndIndexes.document
                }, {}, function(err) {
                    error(err), writer.addIndices(indices, callback);
                });
            } else callback(null);
        }
    };
    return writer;
};

module.exports = restore;
